.. highlight:: git_shell

Ryppl: a prototype
==================

It's *Ryppl* pronounced "ripple".  Currently the *mainline* of ryppl
contains a reorganized boost.cmake 1.41.0.  The only released project
that has been separated from the main release is **wave**.  Three
sandbox projects have been added, as modules: **chrono**, **process**,
and **fiber**.  

.. _getting_started:

Getting started
---------------

Clone the superproject
^^^^^^^^^^^^^^^^^^^^^^

::

  git clone git://gitorious.org/ryppl/ryppl.git src

This will clone the ryppl *superproject* down to directory ``src``.
Have a look at the contents.  Most of boost is there, but:

* There is no toplevel ``boost`` directory, where one normally finds
  boosts' header files.

* There is a toplevel directory ``include``... but it is empty.

* Under ``libs``, there are empty subdirectories ``wave``,
  ``process``, ``chrono`` and ``fiber``. ::

    % ls -l libs/wave libs/chrono libs/process libs/fiber
    libs/chrono:
    total 0
    
    libs/fiber:
    total 0
    
    libs/process:
    total 0
    
    libs/wave:
    total 0
    
* Other than those four, each project (each one directory) under
  ``libs/`` contains a directory ``include/boost`` inside which are
  headers specific to this project, e.g. for *smart_ptr*::

    % ls libs/smart_ptr/include/boost 
    enable_shared_from_this.hpp
    make_shared.hpp scoped_array.hpp scoped_ptr.hpp shared_array.hpp
    shared_ptr.hpp smart_ptr/ smart_ptr.hpp

  Note that headers are not required to have any particular layout

* In the toplevel there is a file ``.gitmodules`` that maps local
  directories to remote git repositories::

    [submodule "libs/wave"]
          path = libs/wave
          url = git://gitorious.org/ryppl/wave.git
    [submodule "libs/chrono"]
          path = libs/chrono
          url = git://gitorious.org/ryppl/chrono.git
    [submodule "libs/process"]
          path = libs/process
          url = git://gitorious.org/ryppl/process.git
    [submodule "libs/fiber"]
          path = libs/fiber
          url = git://gitorious.org/ryppl/fiber.git
    
* The command ``git submodule status`` gives the commits at which each
  submodule should be cloned::

    % git submodule status
    -6d205b973e41c226eba838ef125d5a14f508e173 libs/chrono
    -413d393f7aaea99c85d8db7bd93e06b99465e84c libs/fiber
    -d0698203f19bf30518f58ce8058dca496dba8ecf libs/process
    -f1e2aa9ad7743beaf11296e4f7d6f960814a86b7 libs/wave

Initialize and update the submodules
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Issue the command ``git submodule init``::

  % git submodule init
  Submodule 'libs/chrono' (git://gitorious.org/ryppl/chrono.git) registered for path 'libs/chrono'
  Submodule 'libs/fiber' (git://gitorious.org/ryppl/fiber.git) registered for path 'libs/fiber'
  Submodule 'libs/process' (git://gitorious.org/ryppl/process.git) registered for path 'libs/process'
  Submodule 'libs/wave' (git://gitorious.org/ryppl/wave.git) registered for path 'libs/wave'

Notice that the *submodule status* has not changed::

  % git submodule status
  -6d205b973e41c226eba838ef125d5a14f508e173 libs/chrono
  -413d393f7aaea99c85d8db7bd93e06b99465e84c libs/fiber
  -d0698203f19bf30518f58ce8058dca496dba8ecf libs/process
  -f1e2aa9ad7743beaf11296e4f7d6f960814a86b7 libs/wave

Now update the submodules::

  % git submodule update
  Initialized empty Git repository in /tmp/src/libs/chrono/.git/
  remote: Counting objects: 65, done.
  remote: Compressing objects: 100% (56/56), done.
  remote: Total 65 (delta 16), reused 0 (delta 0)
  Receiving objects: 100% (65/65), 79.53 KiB, done.
  Resolving deltas: 100% (16/16), done.
  Submodule path 'libs/chrono': checked out '6d205b973e41c226eba838ef125d5a14f508e173'
  Initialized empty Git repository in /tmp/src/libs/fiber/.git/
  remote: Counting objects: 103, done.
  remote: Compressing objects: 100% (100/100), done.
  remote: Total 103 (delta 34), reused 0 (delta 0)
  Receiving objects: 100% (103/103), 61.92 KiB, done.
  Resolving deltas: 100% (34/34), done.
  Submodule path 'libs/fiber': checked out '413d393f7aaea99c85d8db7bd93e06b99465e84c'
  Initialized empty Git repository in /tmp/src/libs/process/.git/
  remote: Counting objects: 128, done.
  Receiving objects: 100% (128/128), 100.10 KiB, done.g objects:  93% (120/128)   
  Resolving deltas: 100% (40/40), done.g deltas:   0% (0/40)   
  remote: Compressing objects: 100% (87/87), done.
  remote: Total 128 (delta 40), reused 120 (delta 38)
  Submodule path 'libs/process': checked out 'd0698203f19bf30518f58ce8058dca496dba8ecf'
  Initialized empty Git repository in /tmp/src/libs/wave/.git/
  remote: Counting objects: 469, done.
  remote: Compressing objects: 100% (222/222), done.
  remote: Total 469 (delta 233), reused 469 (delta 233)
  Receiving objects: 100% (469/469), 530.36 KiB | 256 KiB/s, done.
  Resolving deltas: 100% (233/233), done.
  Submodule path 'libs/wave': checked out 'f1e2aa9ad7743beaf11296e4f7d6f960814a86b7'
  
That's a lot of output... all that has happened is that a git checkout
of each submodule has been done to its corresponding directory inside
the superproject, and that the checkout has been done at a specific
commit.

Now notice that the git submodule status has changed::

  % git submodule status
  6d205b973e41c226eba838ef125d5a14f508e173 libs/chrono (heads/master)
  413d393f7aaea99c85d8db7bd93e06b99465e84c libs/fiber (heads/master)
  d0698203f19bf30518f58ce8058dca496dba8ecf libs/process (heads/master)
  f1e2aa9ad7743beaf11296e4f7d6f960814a86b7 libs/wave (heads/master)

The minus sign to the left of the hash has disappeared, and a branch
(in parenthesis) has appeared on the right.

Also, the submodule directories now contain code::

  % ls libs/process
  CMakeLists.txt  build/  example/  index.htm  test/
  README.txt      doc/    include/  source/
  
Now you have a **ryppl** workspace nearly ready to build.

Run cmake and generate forwarding headers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Generate makefiles with *cmake* in the standard way.  I like to make a
subdirectory ``build/`` of my clone and run cmake in there, so that I
can always tell which build corresponds to which clone.  This
directory has already been added to ``.gitignore``, so git won't be
distracted by all those new buildfiles::

  % mkdir build
  % cd build
  % cmake ..
  -- The C compiler identification is GNU
  -- The CXX compiler identification is GNU

  [ etc ]

  -- 
  -- Reading boost project directories (per BUILD_PROJECTS) 
  -- 
  -- + preprocessor
  -- + concept_check

  [ etc... note that 'chrono', 'process', etc appear in this list ]

  -- + wave
  -- 
  -- BUILD_TESTS is NONE: skipping test directories. 
  -- 
  -- 
  -- BUILD_TOOLS is NONE: skipping tools. 
  -- 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /tmp/src/build

The last step is to generate forwarding headers.  This techinque is
borrowed from the smart guys at Trolltech ``Qt`` toolkit.  Make the
target **genheaders**::

  % make genheaders
  Scanning dependencies of target genheaders
  Generating central header directory
  Projects located under     :  /tmp/src/libs
  Fwding headers generated in:  /tmp/src/include

                serialization:  178
                    smart_ptr:  59
                 accumulators:  81

                     [etc etc]

                   scope_exit:  1
                          mpl:  1041
                       assign:  16
  Built target genheaders

Now you'll notice that a superproject directory ``include/boost``
exists and is full of headers::

  % ls ../include/boost
  accumulators/                 multi_array/
  algorithm/                    multi_array.hpp
  aligned_storage.hpp           multi_index/

  [etc]

  memory_order.hpp              wave/
  mpi/                          wave.hpp
  mpi.hpp                       weak_ptr.hpp
  mpl/                          xpressive/

And that each file simply forwards to the project from whence it
came::

  % cat ../include/boost/wave.hpp 
  #include "../../libs/wave/include/boost/wave.hpp"

Note also that the presence of generated files in ``build/`` and
``include/`` don't worry git::

  % git status
  # On branch master
  nothing to commit (working directory clean)

Thanks to the file ``.gitignore``.

Build
^^^^^

Now you can build::

  % make boost_fiber
  Scanning dependencies of target boost_fiber-mt-static-debug
  [  0%] Building CXX object libs/fiber/src/CMakeFiles/boost_fiber-mt-static-debug.dir/auto_reset_event.cpp.o
  [  0%] Building CXX object libs/fiber/src/CMakeFiles/boost_fiber-mt-static-debug.dir/condition.cpp.o


Development scenarios
---------------------

Now we'll walk through several development scenarios and have a look
at the workflow.

"Modularize" an existing boost project
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's "modularize" boost.python.  I check out ``ryppl``, which
currently hosts boost.python directly, not as a submodule (though by
the time you read this, python will be a submodule, so try out this
modularization on something else).

I'm in my fresh clone (without having done any ``git submodule init``
or any of that..  you may, but it isn't necessary.)

I cd into the python subdirectory and import its contents into a local
git repository::

  % cd libs/python 
  
  % git init
  Initialized empty Git repository in /tmp/src/libs/python/.git/
  
  % git add .
  
  % git commit -m "modularizing python"
  [master (root-commit) c16bad0] modularizing python
   680 files changed, 79509 insertions(+), 0 deletions(-)
   create mode 100644 CMakeLists.txt
   create mode 100644 build/Jamfile.v2
   create mode 100644 doc/Jamfile
   [etc]
   create mode 100644 todo.txt

You'll notice I've created a new git repository inside a git
repository... this kind of thing would confuse svn, but here it
doesn't matter; unlike subversion, git information exists only at the
root of each clone (in subversion ``.svn`` directories are sprinkled
through the entire checkout).

Meanwhile I've created a repository to hold this project up on
gitorious.  I now push the code there::

  % git push git@gitorious.org:ryppl/python.git
  Counting objects: 714, done.
  Delta compression using up to 8 threads.
  Compressing objects: 100% (708/708), done.
  Writing objects: 100% (714/714), 825.03 KiB, done.
  Total 714 (delta 127), reused 0 (delta 0)
  => Syncing Gitorious... [OK]
  To git@gitorious.org:ryppl/python.git
   + 1b112bc...c16bad0 HEAD -> master 

I've used the *push* url, since I have write access.

Now that I have python's code safely pushed to a separate
publicly-visible repository, I can remove the python code from the
superproject::

  % cd ..               # to directory libs/

  % rm -r python        # remove the files

  % git rm -r python    # stage the 'rm' for commit
  rm 'libs/python/CMakeLists.txt'
  rm 'libs/python/build/Jamfile.v2'
  rm 'libs/python/doc/Jamfile'
  ...

  % git commit -m "bye bye python"
  [master 2efae00] bye bye python
   680 files changed, 0 insertions(+), 79509 deletions(-)
   delete mode 100644 libs/python/CMakeLists.txt
   ...
   delete mode 100644 libs/python/todo.txt

For sanity let's verify that the working copy is clean::

  % git status
  # On branch master
  nothing to commit (working directory clean)

Now add the git submodule to the superproject::

  % git submodule add git://gitorious.org/ryppl/python.git libs/python
  Initialized empty Git repository in /tmp/src/libs/python/.git/
  remote: Counting objects: 714, done.
  remote: Compressing objects: 100% (581/581), done.
  remote: Total 714 (delta 127), reused 714 (delta 127)
  Receiving objects: 100% (714/714), 825.03 KiB | 674 KiB/s, done.
  Resolving deltas: 100% (127/127), done.
  
.. note:: Notice I have used the ``git://`` url, not the ``git@`` url.
   	  The ``git://`` url is readonly and is the only type of URL
   	  that should be committed to the superproject.  The ``git@``
   	  urls are readwrite and authenticated via SSH.  I will soon
   	  use the latter to push commits from submodules, but I never
   	  commit them to superprojects.

Git has checked out the submodule for us.  If I check the status of
the superproject, I'll see::

  % git status
  # On branch master
  # Your branch is ahead of 'origin/master' by 1 commit.
  #
  # Changes to be committed:
  #   (use "git reset HEAD <file>..." to unstage)
  #
  #       modified:   .gitmodules
  #       new file:   libs/python
  #
  
And 'git diff --cached' shows me::

  % git diff --cached
  diff --git a/.gitmodules b/.gitmodules
  index a74cbf4..f6067c4 100644
  --- a/.gitmodules
  +++ b/.gitmodules
  @@ -10,3 +10,6 @@
   [submodule "libs/fiber"]
          path = libs/fiber
          url = git://gitorious.org/ripple/fiber.git
  +[submodule "libs/python"]
  +       path = libs/python
  +       url = git://gitorious.org/ryppl/python.git
  diff --git a/libs/python b/libs/python
  new file mode 160000    <----------------- note funny-looking mode
  index 0000000..c16bad0
  --- /dev/null
  +++ b/libs/python
  @@ -0,0 +1 @@
  +Subproject commit c16bad0e3f847375872e53bac319d2f724fbf569
  
Here we see a few lines added to .gitmodules as well as *new file
mode 160000*...  this is a special file (not a real file that you can
see in the checkout) that records the commit at which the submodule
should be checked out.  This is the same special file that we see in
the line *new file: libs/python* of ``git status``.  The hash is the
same one that we see in the current output of ``git submodule status``::

  % git submodule status
  -6d205b973e41c226eba838ef125d5a14f508e173 libs/chrono
  -413d393f7aaea99c85d8db7bd93e06b99465e84c libs/fiber
  -d0698203f19bf30518f58ce8058dca496dba8ecf libs/process
  -c16bad0e3f847375872e53bac319d2f724fbf569 libs/python
  -f1e2aa9ad7743beaf11296e4f7d6f960814a86b7 libs/wave
  
To finish up let's commit::

 % git commit -m "modularized python"
 [master 525e3b0] modularized python
  2 files changed, 4 insertions(+), 0 deletions(-)
  create mode 160000 libs/python

To recap, to modularize project **P** I have:

* Created a publicly-visible repository **PR** to hold the project I'm
  modularizing
* Imported **P** into a single git repo and pushed the results to
  **PR**.
* Deleted all trace of **P** from the superproject and committed
  the deletion.
* Added **PR** as a submodule to the superproject with directory
  ``libs/**P**``.
* Committed the addition to the superproject and pushed the results.

Now, looking at my submodule status::

   % git submodule status
   -6d205b973e41c226eba838ef125d5a14f508e173 libs/chrono
   -413d393f7aaea99c85d8db7bd93e06b99465e84c libs/fiber
   -d0698203f19bf30518f58ce8058dca496dba8ecf libs/process
   -c16bad0e3f847375872e53bac319d2f724fbf569 libs/python
   -f1e2aa9ad7743beaf11296e4f7d6f960814a86b7 libs/wave

I see the same thing as I did on initial checkout, with the addition
of one extra submodule (in this case python).  I get the workspace
ready for build with the same steps in first part of
:ref:`getting_started`:

* git submodule init
* git submodule update
* run cmake
* make genheaders
* ???
* profit


 



Say I have a lot of modifications to ``boost.python`` that I've been
working on.  Some of my clients are using my modifications, but
they're not yet in upstream boost, if they'll ever be. I need to
make in-house releases of boost-plus-my-new-python-features and at the
same time have my code and docs maximally avaiable to the boost
community, if I ever hope to have the changes adopted upstream, which
would both make a contribution to boost and simplify my job.

I'm going to need two public repositories: one for my python
modifications, and one for my (slight) modifications to the
superproject.  The first is absolutely necessary, the second, less so.

Create a repository for the python project
""""""""""""""""""""""""""""""""""""""""""

I've created this on gitorious alongside the others, but this isn't
required, it could be anywhere on the net.

* Make a clone of **mainline** up on gitorious
* Clone this clone downstream
* Create an 


  


Good Links
==========

* http://www.kernel.org/pub/software/scm/git/docs/git-submodule.html
* http://woss.name/blog/2008/4/9/using-git-submodules-to-track-plugins.html

